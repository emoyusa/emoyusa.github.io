<!DOCTYPE html>
<style>

.axis .domain {
  display: none;
}

.d3-tip {

	line-height: 1;

	font-size: 10px;
	font-weight: bold;

	padding: 3px;

	background: rgba(0, 0, 0, 0.8);

	color: #fff;

	border-radius: 2px;
}

</style>
<h2 align="center">Prevalence of Top 50 Diagnosed Conditions among Veteran VHA Patients Age 18-44 Years by Race/Ethnicity, FY14</h2>
<p align="center"> Click on Legend Below to Hide or Select Groups.&emsp;
  <a href="#notes">Go to Notes.</a>&emsp;
  <a href="tableAge18_44.html">Go to Table.</a></p>
<svg width="800" height="6000"></svg>
<h3><a name="notes">Notes:</h3>
<p>Key: AIAN = American Indian/Alaska Native; Black = Black/African American; NHOPI = Native Hawaiian/Other Pacific Islander.</p>
<p>Denominator: Veteran FY2014 VHA patients (Data source = WHEI Master Database).</p>
<p>Population Counts, Age 18-44: Total=963,739; White=584,873; Black=181,133; Hispanic=103,636; Asian=17,819; NHOPI=7,452; AIAN=7,868; >1 Race=10,589; Unknown=50,369.</p>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.7.1/d3-tip.min.js'></script>
<script>

var svg = d3.select("svg"),
    margin = {top: 30, right: 20, bottom: 30, left: 275},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// The scale spacing the groups:
var y0 = d3.scaleBand()
    .rangeRound([0, height])
    .paddingInner(0.1);

// The scale for spacing each group's bar:
var y1 = d3.scaleBand()
    .padding(0.05);

var x = d3.scaleLinear()
    .rangeRound([0, width]);

var z = d3.scaleOrdinal()
    .range(["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"]);

var tip = d3.tip()

	.attr('class', 'd3-tip')

	.offset([13, 0])

	.html(function(d) {
    return (d.key);
  });



svg.call(tip);

d3.csv("top50age18_44.csv", function(d, i, columns) {
  for (var i = 1, n = columns.length; i < n; ++i) d[columns[i]] = +d[columns[i]];
  return d;
}, function(error, data) {
  if (error) throw error;

  var keys = data.columns.slice(1);

  y0.domain(data.map(function(d) { return d.DIAGNOSIS; }));
  y1.domain(keys).rangeRound([0, y0.bandwidth()]);

  x.domain([0, d3.max(data, function(d) { return d3.max(keys, function(key) { return d[key]; }); })]).nice();

 g.append("g")
    .selectAll("g")
    .data(data)
    .enter().append("g")
    .attr("class","bar")
    .attr("transform", function(d) { return "translate(0," + y0(d.DIAGNOSIS) + ")"; })
    .selectAll("rect")
    .data(function(d) { return keys.map(function(key) { return {key: key, value: d[key]}; }); })
    .enter().append("rect")
      .attr("y", function(d) { return y1(d.key); })
      .attr("x", 0)
      .attr("height", y1.bandwidth())
      .attr("width", function(d) { return x(d.value); })
      .attr("fill", function(d) { return z(d.key); })
      .on("mouseover", tip.show)
      .on("mouseout", tip.hide)

g.append("g")
    .selectAll("g")
    .data(data)
    .enter().append("g")
    .attr("class","text")
    .attr("transform", function(d) { return "translate(0," + y0(d.DIAGNOSIS) + ")"; })
    .selectAll("text")
    .data(function(d) { return keys.map(function(key) { return {key: key, value: d[key]}; }); })
    .enter().append("text")
      .attr("y", function(d) { return y1(d.key)+y1.bandwidth()*4/5; })
      .attr("x", function(d) { return x(d.value)+1; })
      .style("font-family", "sans-serif")
      .style("font-size", y1.bandwidth()-1)
      .style("font-weight", "bold")
      .text(function(d) { return d3.format(".1f") (d.value)+"%"; });

  g.append("g")
      .attr("class", "y axis")
      .attr("font-weight", "bold")
      .call(d3.axisLeft(y0));

  g.append("g")
      .attr("class", "axis")
      .attr("font-weight", "bold")
      .attr("transform","translate(0,"+height+")")
      .call(d3.axisBottom(x).ticks(null))
    .append("text")
      .attr("y", 27)
      .attr("x", 0)
      .attr("dx", "0.32em")
      .attr("fill", "#000")
      .attr("font-weight", "bold")
      .attr("text-anchor", "start")
      .text("Percent of Population with Diagnosis");

  g.append("g")
      .attr("class", "axis")
      .attr("font-weight", "bold")
      .call(d3.axisTop(x).ticks(null))
    .append("text")
      .attr("y", -22)
      .attr("x", 0)
      .attr("dx", "0.32em")
      .attr("fill", "#000")
      .attr("font-weight", "bold")
      .attr("text-anchor", "start")
      .text("Percent of Population with Diagnosis");

  var legend = g.append("g")
      .attr("font-family", "sans-serif")
      .attr("font-size", 10)
      .attr("font-weight", "bold")
      .attr("text-anchor", "end")
    .selectAll("g")
    .data(keys.slice())
    .enter().append("g")
      .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", -200)
      .attr("y",150)
      .attr("width", 15)
      .attr("height", 15)
      .attr("fill", z)
      .attr("stroke", z)
      .attr("stroke-width",2)
      .on("click",function(d) { update(d) });

  legend.append("text")
      .attr("x", -210)
      .attr("y", 159.5)
      .attr("dy", "0.32em")
      .text(function(d) { return d; });

  var filtered = [];


  ////
  //// Update and transition on click:
  ////

  function update(d) {

    //
    // Update the array to filter the chart by:
    //

    // add the clicked key if not included:
    if (filtered.indexOf(d) == -1) {
     filtered.push(d);
      // if all bars are un-checked, reset:
      if(filtered.length == keys.length) filtered = [];
    }
    // otherwise remove it:
    else {
      filtered.splice(filtered.indexOf(d), 1);
    }

    //
    // Update the scales for each group(/states)'s items:
    //
    var newKeys = [];
    keys.forEach(function(d) {
      if (filtered.indexOf(d) == -1 ) {
        newKeys.push(d);
      }
    })
    y1.domain(newKeys).rangeRound([0, y0.bandwidth()]);
    x.domain([0, d3.max(data, function(d) { return d3.max(keys, function(key) { if (filtered.indexOf(key) == -1) return d[key]; }); })]).nice();

    // update the x axis:
            svg.select(".x")
            .transition()
            .call(d3.axisLeft(x).ticks(null))
            .duration(500);


    //
    // Filter out the bands that need to be hidden:
    //
    var bars = svg.selectAll(".bar").selectAll("rect")
      .data(function(d) { return keys.map(function(key) { return {key: key, value: d[key]}; }); })

   bars.filter(function(d) {
         return filtered.indexOf(d.key) > -1;
      })
      .transition()
      .attr("y", function(d) {
        return (+d3.select(this).attr("y")) + (+d3.select(this).attr("height"))/2;
      })
      .attr("height",0)
      .attr("width",0)
      .attr("x",0)
      .duration(500);

    //
    // Adjust the remaining bars:
    //
    bars.filter(function(d) {
        return filtered.indexOf(d.key) == -1;
      })
      .transition()
      .attr("y", function(d) { return y1(d.key); })
      .attr("x",0)
      .attr("width", function(d) { return x(d.value); })
      .attr("height", y1.bandwidth())
      .attr("fill", function(d) { return z(d.key); })
      .duration(500);

    var labels = svg.selectAll(".text").selectAll("text")
      .data(function(d) { return keys.map(function(key) { return {key: key, value: d[key]}; }); })

   labels.filter(function(d) {
         return filtered.indexOf(d.key) > -1;
      })
      .transition()
      .attr("y", function(d) {
        return (+d3.select(this).attr("y")) + (+d3.select(this).attr("height"))/2;
      })
      .attr("height",0)
      .attr("width",0)
      .attr("x",0)
      .text("")
      .duration(500);

    //
    // Adjust the remaining labels:
    //
    labels.filter(function(d) {
        return filtered.indexOf(d.key) == -1;
      })
      .transition()
      .attr("y", function(d) { return y1(d.key)+y1.bandwidth()*4/5; })
      .attr("x", function(d) { return x(d.value)+1; })
      .style("font-family", "sans-serif")
      .style("font-size", y1.bandwidth()-1)
      .style("font-weight", "bold")
      .text(function(d) { return d3.format(".1f") (d.value)+"%"; })
      .duration(500);



    // update legend:
    legend.selectAll("rect")
      .transition()
      .attr("fill",function(d) {
        if (filtered.length) {
          if (filtered.indexOf(d) == -1) {
            return z(d);
          }
           else {
            return "white";
          }
        }
        else {
         return z(d);
        }
      })
      .duration(100);


  }

});

</script>
